#include <cassert>
#include <queue>

#include <isoreconfig/isomorphic.hpp>
#include <isoreconfig/isoreconfig.hpp>
#include <configuration/serialization.hpp>

using VisitedId = size_t;

namespace rofi::isoreconfig {

using namespace rofi::configuration;


bool equalConfig( const RofiWorld& bot1, const RofiWorld& bot2 )
{
    return equalShape( bot1, bot2, true );
}

void saveToFile( const RofiWorld& bot, const std::string& path )
{
    auto jason = serialization::toJSON( bot );
    std::ofstream out(path);
    // std::cout << jason.dump() << "\n";
    out << jason.dump();
    out.close();
}

bool withinBounds( const std::span< float >& values, 
    const std::span< const std::pair< float, float > >& bounds )
{
    auto valIt = values.begin();
    for ( auto[low, high] : bounds )
    {
        if ( *valIt < low || high < *valIt ) 
            return false;
        ++valIt;
    }

    return true;
}

class Shapes
{
    std::vector< RofiWorld > _visited;

public:
    Shapes() = default;

    bool contains( const RofiWorld& bot ) const
    {
        for ( const RofiWorld& found : _visited )
            if ( equalConfig( found, bot ) ) 
                return true;
            
        return false;
    }

    auto find( const RofiWorld& bot )
    {
        return find_if( _visited.begin(), _visited.end(), 
            [&]( const RofiWorld& found ){ return equalConfig( found, bot ); } );
    }

    VisitedId insert( const RofiWorld& bot )
    {
        _visited.push_back( bot );
        return _visited.size() - 1;
    }

    RofiWorld& operator[]( size_t i )
    {
        return _visited[i];
    }

    const RofiWorld& operator[]( size_t i ) const
    {
        return _visited[i];
    }

    size_t size() const
    {
        return _visited.size();
    }
};

void generateParametersRec( std::vector< std::vector< float > >& result, std::vector< float >& current,
     const std::array< float, 3 >& possChange, size_t toBeAdded )
{
    if ( toBeAdded == 0 ) 
    {
        result.push_back( current );
        return;
    }

    for ( float change : possChange )
    {
        current.push_back( change );
        generateParametersRec( result, current, possChange, toBeAdded - 1 );
        assert( current.size() > 0 );
        current.pop_back();
    }
}

std::vector< std::vector< float > > generateParameters( size_t dog, float step ) 
{
    std::vector< std::vector< float > > result;
    std::array< float, 3 > possChange { -step, step, 0 };
    std::vector< float > current;

    generateParametersRec( result, current, possChange, dog );
    assert( result.back() == std::vector< float >( dog, 0 ) );
    result.pop_back(); // Remove identity
    return result;
}

// Get possible configurations made from the current one
// "1 step" away, (TODO ignoring configurations of identical classes?)
std::vector< RofiWorld > getDescendants(
    const RofiWorld& current, float step, unsigned int bound ) 
{
    std::vector< RofiWorld > result;

    // Descendants generated by changing joint parameters (e. g. rotation of a module)
    for ( const auto& modInf : current.modules() )
    {
        for ( size_t j = 0; j < modInf.module->joints().size(); ++j )
        {
            auto& currJoint = modInf.module->joints()[j].joint;
            // TODO generate rotations for all reocurring dogs in advance
            for ( auto& possRot : generateParameters( currJoint->positions().size(), step ) )
            {                
                RofiWorld newBot = current;

                // Shouldnt work - is const
                // newBot.getModule(  modInf.module->getId() )->joints()[j].joint->changePositions( possRot );

                // Skip rotation if it does not respect joint bounds
                if ( !newBot.getModule(  modInf.module->getId() )->changeJointPositionsBy( j, possRot ).has_value() )
                    continue;

                if ( newBot.prepare().has_value() && newBot.isValid() )
                    result.push_back( newBot );
            }
        }
    }

    // Descendants generated by disconnecting already connected roficoms
    auto allConnects = current.roficomConnections();
    for ( auto start = allConnects.begin(); start != allConnects.end(); ++start )
    {
        RofiWorld newBot = current;
        newBot.disconnect( start.get_handle() );

        if ( newBot.prepare().has_value() && newBot.isValid() )
            result.push_back( newBot );
    }

    // Generate all possible new connections from mod-comp to mod-comp
    std::vector< std::tuple< ModuleId, int, ModuleId, int, roficom::Orientation > > possConnect;
    for ( const auto& modInf : current.modules() )
    {
        assert( modInf.module->type == ModuleType::Universal );

        for ( const auto& conn : modInf.module->connectors() )
        {
            assert( conn.type == ComponentType::Roficom );
            std::optional<std::pair< const Component&, roficom::Orientation >> poss = conn.getNearConnector();

            if ( !poss ) continue; // No possible connection for roficom <conn>

            assert( poss->first.type == ComponentType::Roficom );
            assert( poss->first.parent );

            ModuleId mod1 = modInf.module->getId();
            int comp1 = conn.getIndexInParent();
            ModuleId mod2 = poss->first.parent->getId();
            int comp2 = poss->first.getIndexInParent();

            bool alreadyConnected = false;
            for ( const auto& rofiJoint : current.roficomConnections() )
                if ( ( rofiJoint.getSourceModule( current ).getId() == mod1 && rofiJoint.sourceConnector == comp1 
                    && rofiJoint.getDestModule( current ).getId() == mod2 && rofiJoint.destConnector == comp2 ) ||
                    ( rofiJoint.getSourceModule( current ).getId() == mod2 && rofiJoint.sourceConnector == comp2 
                    && rofiJoint.getDestModule( current ).getId() == mod1 && rofiJoint.destConnector == comp1 ) )
                    { alreadyConnected = true; break; }

            if ( alreadyConnected ) continue;
            auto newConn = std::tie( mod1, comp1, mod2, comp2, poss->second );
            possConnect.push_back( newConn );
        }
    }

    // filter duplicates
    std::vector< std::tuple< ModuleId, int, ModuleId, int, roficom::Orientation > > noDupes;
    for ( const auto&[ conn1mod1, conn1comp1, conn1mod2, conn1comp2, conn1ori ] : possConnect )
    {
        // Connector cannot be connected to itself
        assert( conn1mod1 != conn1mod2 || conn1comp1 != conn1comp2 );

        bool add = true;
        for ( const auto&[ conn2mod1, conn2comp1, conn2mod2, conn2comp2, _ ] : noDupes )
        {
            // Every connector can be connected only to one other connector
            assert( conn1mod1 != conn2mod1 || conn1comp1 != conn2comp1 );
            
            if ( conn1mod1 == conn2mod2 && conn1comp1 == conn2comp2 )
                { add = false; break; }
        }
        if ( add ) 
            noDupes.push_back( std::tie( conn1mod1, conn1comp1, conn1mod2, conn1comp2, conn1ori ) );
    }
    possConnect = std::move( noDupes );

    // Generate new rofibots by connecting adjacent roficoms
    for ( const auto&[ mod1, comp1, mod2, comp2, orient ] : possConnect )
    {
        RofiWorld newBot = current;
        connect( 
            newBot.getModule( mod1 )->components()[ comp1 ], 
            newBot.getModule( mod2 )->components()[ comp2 ],
            orient );
        assert( current.isPrepared() );
        
        if ( newBot.prepare().has_value() && newBot.isValid() )
            result.push_back( newBot );
    }

    return result;
}

// Make a vector of predecessors of target configuration from map of predecessors
// Assume target is reachable from start in predecessors map
std::vector< RofiWorld > getPredecessors( const Shapes& visited,
    std::unordered_map< VisitedId, VisitedId >& predecessor, 
    VisitedId target, VisitedId start )
{
    assert( predecessor.contains( start ) );
    assert( predecessor.contains( target ) );

    std::vector<RofiWorld> result;
    VisitedId current = target;
    
    while ( current != start ) {

        result.push_back( visited[current] );
        // current must always have a predecessor or given map is not correct
        assert( predecessor.contains( current ) );
        current = predecessor.find( current )->second;
    }

    result.push_back( visited[start] );
    std::reverse( result.begin(), result.end() );
    return result;
} 

// Assume target is reachable from start (same number of (only) **universal** modules)
// using only rotations given by <step>
std::vector<RofiWorld> bfsShapes(
    const RofiWorld& start, const RofiWorld& target,
    float step, unsigned int bound/*, BFSReporter& reporter*/ )
{
    Shapes visited;
    
    std::unordered_map< VisitedId, VisitedId > predecessor;
    std::unordered_map< VisitedId, int > distance;

    VisitedId startId = visited.insert( start );
    // reporter.onUpdateSeen( visited );

    // Starting configuration has itself as predecessor and distance of 0
    predecessor.insert( { startId, startId } );
    // reporter.onUpdatePredecessors( predecessor );
    distance.insert( { startId, 0 } );
    // reporter.onUpdateDistance( distance );

    size_t currDis = 0;

    // start is isomorphic to target
    if ( equalConfig( start, target ) ) 
        return getPredecessors( visited, predecessor, startId, startId );

    std::queue< VisitedId > bfsQueue;

    bfsQueue.push( startId );
    // reporter.onUpdateQueue( bfsQueue );

    while ( !bfsQueue.empty() ) 
    {
        VisitedId current = bfsQueue.front();
        // reporter.onUpdateCurrent( *current );
        bfsQueue.pop();
        // reporter.onUpdateQueue( bfsQueue );

        if ( distance.find( current )->second != currDis )
        {
            assert( currDis == distance.find( current )->second - 1 );
            ++currDis;
            std::cout << "current distance: " << currDis << "\n";
            std::cout << "queue size: " << bfsQueue.size() << "\n";
            std::cout << "Visited shapes: " << visited.size() << "\n";
        }

        assert( equalConfig( start, visited[startId] ) );
        assert( start.isPrepared() );
        std::vector< RofiWorld > descendants = getDescendants( visited[current], step, bound );
        assert( start.isPrepared() );

        assert( equalConfig( start, visited[startId] ) );

        for ( const RofiWorld& child : descendants ) {
            if ( visited.contains( child ) ) continue;

            VisitedId childId = visited.insert( child );

            // reporter.onUpdateSeen( visitedChild );
            predecessor.insert({ childId, current });
            // reporter.onUpdatePredecessors(predecessor);
            assert( distance.find( current ) != distance.end() );
            distance.insert({ childId, distance.find( current )->second + 1 });
            // reporter.onUpdateDistance(distance);

            if ( equalConfig( child, target ) ) 
            {
                std::vector< RofiWorld > output = getPredecessors( visited, predecessor, childId, startId );
                // reporter.onBuildPredecessors( output );
                std::cout << "Visited shapes: " << visited.size() << "\n";
                return output;
            }

            bfsQueue.push( childId );
            // reporter.onUpdateQueue( bfsQueue );
        }
    }
    std::vector< RofiWorld > output = {};
    // reporter.onBuildPredecessors(output);
    std::cout << "Visited shapes: " << visited.size() << "\n";
    std::cout << "Path does not exist\n";
    return output;
}

} // namespace rofi::isoreconfig
